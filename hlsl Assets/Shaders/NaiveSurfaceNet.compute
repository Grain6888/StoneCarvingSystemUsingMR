#pragma kernel CSMain

// ボクセルデータ
StructuredBuffer<float> voxel;
// 出力バッファ
RWStructuredBuffer<float3> vertexBuffer;
RWStructuredBuffer<int> indexBuffer;
RWStructuredBuffer<int> triangleBuffer;

// パラメータ
cbuffer Params
{
    int sizeX;
    int sizeY;
    int sizeZ;
    int yLayer;
    int maxVertexBufferSize;
    int maxTriangleBufferSize;
};

[numthreads(8, 1, 8)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    int x = id.x;
    int z = id.z;
    int y = yLayer;

    if (x >= sizeX - 1 || z >= sizeZ - 1)
        return;

    // MakeVertex相当の処理
    int kind = 0;
    for (int i = 0; i < 8; i++)
    {
        int vx = x + neighborTable[i][0];
        int vy = y + neighborTable[i][1];
        int vz = z + neighborTable[i][2];
        int idx = vx + vz * sizeX + vy * sizeX * sizeZ;
        if (0 > voxel[idx])
            kind |= 1 << i;
    }
    if (kind == 0 || kind == 255)
        return;

    // 頂点位置計算
    float3 vertex = float3(0, 0, 0);
    int crossCount = 0;
    for (int i = 0; i < 12; i++)
    {
        int startVertex = edgeTable[i][0];
        int endVertex = edgeTable[i][1];
        if (((kind >> startVertex) & 1) == ((kind >> endVertex) & 1))
            continue;

        int sx = x + neighborTable[startVertex][0];
        int sy = y + neighborTable[startVertex][1];
        int sz = z + neighborTable[startVertex][2];
        int ex = x + neighborTable[endVertex][0];
        int ey = y + neighborTable[endVertex][1];
        int ez = z + neighborTable[endVertex][2];

        int sidx = sx + sz * sizeX + sy * sizeX * sizeZ;
        int eidx = ex + ez * sizeX + ey * sizeX * sizeZ;

        float svalue = voxel[sidx];
        float evalue = voxel[eidx];

        float3 sv = float3(sx, sy, sz);
        float3 ev = float3(ex, ey, ez);
        vertex += lerp(sv, ev, (0 - svalue) / (evalue - svalue));
        crossCount++;
    }
    vertex /= crossCount;

    // 頂点バッファ・インデックスバッファへの書き込み
    int vIndex = x + z * sizeX + y * sizeX * sizeZ;
    vertexBuffer[vIndex] = vertex;
    indexBuffer[vIndex] = vIndex;

    // MakeSurface相当の処理（省略例：必要に応じて追加）
    // triangleBuffer[...] = ...;
}

// テーブルは定数配列として定義
static const int2 edgeTable[12] =
{
    int2(0, 1), int2(1, 2), int2(2, 3), int2(3, 0),
    int2(4, 5), int2(5, 6), int2(6, 7), int2(7, 4),
    int2(0, 4), int2(1, 5), int2(2, 6), int2(3, 7)
};
static const int3 neighborTable[8] =
{
    int3(0, 0, 0), int3(1, 0, 0), int3(1, 0, 1), int3(0, 0, 1),
    int3(0, 1, 0), int3(1, 1, 0), int3(1, 1, 1), int3(0, 1, 1)
};
