#pragma kernel MeshReconstruction
#pragma kernel ClearUnused

// HLSL に sizeof 演算子がないための回避策
#define SIZEOF_UINT 4
#define SIZEOF_FLOAT2 8
#define SIZEOF_FLOAT3 12
#define VERTEX_STRIDE (SIZEOF_FLOAT3*2 + SIZEOF_FLOAT2) // pos + normal + uv

// パラメーター
uint3 Dims;
uint MaxTriangle;
float Scale;
float Isovalue;

// CellFlags (C# と一致)
static const uint CELLFLAG_IS_FILLED = 1u;

// グリッド空間からオブジェクト空間への変換 (原点基準)
float3 TransformPoint(float3 p)
{
    return p * Scale;
}

//
// 各キューブ構成に対する三角形リストを保持する「TriangleTable」
//
StructuredBuffer<uint2> TriangleTable;

uint EdgeIndexFromTriangleTable(uint2 data, uint index)
{
    return 0xfu & (index < 8 ? data.x >> ((index + 0) * 4) :
                               data.y >> ((index - 8) * 4));
}

//
// 入力: DataChunk の各セルの status をそのまま受け取る
//
StructuredBuffer<uint> Voxels;

bool HasFlag(uint flags, uint bit)
{
    return (flags & bit) != 0;
}

float VoxelValue(uint x, uint y, uint z)
{
    // 指定のインデックス対応: index = x + (z * Dims.x) + (y * Dims.x * Dims.z)
    uint idx = x + Dims.x * z + (Dims.x * Dims.z) * y;
    uint flags = Voxels[idx];
    return HasFlag(flags, CELLFLAG_IS_FILLED) ? 1.0 : 0.0;
}

// 勾配を計算したボクセル値
float4 VoxelValueWithGradient(uint3 i)
{
    uint3 i_n = max(i, 1) - 1;
    uint3 i_p = min(i + 1, Dims - 1);
    float v = VoxelValue(i.x, i.y, i.z);
    float v_nx = VoxelValue(i_n.x, i.y, i.z);
    float v_px = VoxelValue(i_p.x, i.y, i.z);
    float v_ny = VoxelValue(i.x, i_n.y, i.z);
    float v_py = VoxelValue(i.x, i_p.y, i.z);
    float v_nz = VoxelValue(i.x, i.y, i_n.z);
    float v_pz = VoxelValue(i.x, i.y, i_p.z);
    return float4(v_px - v_nx, v_py - v_ny, v_pz - v_nz, v);
}

//
// 出力バッファとカウンター
//
RWByteAddressBuffer VertexBuffer;
RWByteAddressBuffer IndexBuffer;
RWStructuredBuffer<uint> Counter; // カウントのみに使用

// 頂点バッファ アクセサ
void WriteVertex(uint offset, float3 p, float3 n)
{
    uint base_addr = offset * VERTEX_STRIDE;
    uint addr_pos = base_addr;
    uint addr_nrm = addr_pos + SIZEOF_FLOAT3;
    uint addr_uv = addr_nrm + SIZEOF_FLOAT3;

    float3 an = abs(n);
    float2 uv;
    float invX = 1.0 / (Dims.x * Scale);
    float invY = 1.0 / (Dims.y * Scale);
    float invZ = 1.0 / (Dims.z * Scale);

    if (an.y >= an.x && an.y >= an.z) // 上下 -> XZ
    {
        uv = float2(p.x * invX, p.z * invZ);
    }
    else if (an.x >= an.z) // ±X 側面 -> ZY
    {
        uv = float2(p.z * invZ, p.y * invY);
    }
    else // ±Z 側面 -> XY
    {
        uv = float2(p.x * invX, p.y * invY);
    }

    VertexBuffer.Store3(addr_pos, asuint(p));
    VertexBuffer.Store3(addr_nrm, asuint(n));
    VertexBuffer.Store2(addr_uv, asuint(uv));
}

// インデックス バッファ アクセサ
void WriteIndices(uint offset, uint3 indices)
{
    IndexBuffer.Store3(offset * SIZEOF_UINT, indices);
}

//
// キューブのジオメトリ/トポロジ
//
// これは Paul Bourke の記事で定義されているものと一致している必要がある:
// http://paulbourke.net/geometry/polygonise/
//
uint3 CubeVertex(uint index)
{
    bool x = index & 1;
    bool y = index & 2;
    bool z = index & 4;
    return uint3(x ^ y, y, z);
}

uint2 EdgeVertexPair(uint index)
{
    // (0, 1) (1, 2) (2, 3) (3, 0)
    // (4, 5) (5, 6) (6, 7) (7, 4)
    // (0, 4) (1, 5) (2, 6) (3, 7)
    uint v1 = index & 7;
    uint v2 = index < 8 ? ((index + 1) & 3) | (index & 4) : v1 + 4;
    return uint2(v1, v2);
}

//
// マーチングキューブ メッシュ再構築カーネル
//
[numthreads(4, 4, 4)]
void MeshReconstruction(uint3 id : SV_DispatchThreadID)
{
    // 境界チェック
    if (any(id + 1 >= Dims.xyz))
        return;

    // 各キューブ頂点でのボクセルサンプル
    float4 samples[8];
    for (uint i = 0; i < 8; i++)
        samples[i] = VoxelValueWithGradient(id + CubeVertex(i));

    // キューブ構成セレクタ
    // （頂点の二値状態のビットフィールドとして初期化）
    uint selector = 0;
    for (i = 0; i < 8; i++)
        selector |= (samples[i].w < Isovalue) << i;

    // 空のキューブの特例。交差がない場合は早期に終了。
    if (selector == 0 || selector == 0xff)
        return;

    // 各エッジ上の交差点
    // GPU 指向の方法で行う。交差のないエッジも含め、すべてのエッジで計算を行う。
    float3 vertices[12];
    float3 normals[12];
    for (i = 0; i < 12; i++)
    {
        uint2 pair = EdgeVertexPair(i);
        float4 sample1 = samples[pair.x];
        float4 sample2 = samples[pair.y];
        float3 vertex1 = id + CubeVertex(pair.x);
        float3 vertex2 = id + CubeVertex(pair.y);
        float param = (Isovalue - sample1.w) / (sample2.w - sample1.w);
        vertices[i] = TransformPoint(lerp(vertex1, vertex2, param));
        normals[i] = -normalize(lerp(sample1.xyz, sample2.xyz, param));
    }

    // 選択されたキューブ構成で三角形を出力する。
    uint2 tri_data = TriangleTable[selector];
    for (i = 0; i < 15; i += 3)
    {
        uint e1 = EdgeIndexFromTriangleTable(tri_data, i);
        uint e2 = EdgeIndexFromTriangleTable(tri_data, i + 1);
        uint e3 = EdgeIndexFromTriangleTable(tri_data, i + 2);
        if (e1 == 15)
            return;

        uint count = Counter.IncrementCounter();
        if (count >= MaxTriangle)
            return;

        uint vidx = count * 3;
        WriteVertex(vidx + 0, vertices[e1], normals[e1]);
        WriteVertex(vidx + 1, vertices[e2], normals[e2]);
        WriteVertex(vidx + 2, vertices[e3], normals[e3]);
        WriteIndices(vidx, uint3(vidx, vidx + 1, vidx + 2));
    }
}

//
// バッファの未使用領域をクリアするクリーンアップ カーネル
//
[numthreads(64, 1, 1)]
void ClearUnused(uint id : SV_DispatchThreadID)
{
    while (true)
    {
        uint count = Counter.IncrementCounter();
        if (count >= MaxTriangle)
            break;
        uint vidx = count * 3;
        WriteVertex(vidx + 0, float3(0, 0, 0), float3(0, 0, 0));
        WriteVertex(vidx + 1, float3(0, 0, 0), float3(0, 0, 0));
        WriteVertex(vidx + 2, float3(0, 0, 0), float3(0, 0, 0));
        WriteIndices(vidx, uint3(0, 0, 0));
    }
}
